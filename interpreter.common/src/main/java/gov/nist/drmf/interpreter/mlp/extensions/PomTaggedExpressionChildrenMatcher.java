package gov.nist.drmf.interpreter.mlp.extensions;

import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * This class should only be generated by {@link MatchablePomTaggedExpression} due
 * initialization. This class handles the children (components) of the given parent.
 * It also provide helpful functions to match child components.
 * @author Andre Greiner-Petter
 */
public class PomTaggedExpressionChildrenMatcher {
    /**
     * The reference parent.
     */
    private final MatchablePomTaggedExpression parent;

    /**
     * The group captures
     */
    private final GroupCaptures captures;

    /**
     * The children of the parent node
     */
    private final LinkedList<MatchablePomTaggedExpression> children;

    /**
     * @param parent the parent node
     */
    PomTaggedExpressionChildrenMatcher(
            MatchablePomTaggedExpression parent,
            GroupCaptures groupCaptures
    ) {
        this.parent = parent;
        this.captures = groupCaptures;
        this.children = new LinkedList<>();
    }

    /**
     * Adds a node the list of children.
     * It updates the provided parent node as well.
     * @param cpte new child
     */
    public void add( MatchablePomTaggedExpression cpte ) {
        this.parent.addComponent(cpte);
        this.children.add(cpte);
    }

    /**
     * @return true if the first child is a wildcard otherwise false.
     * It also returns false if there are no children added yet.
     */
    public boolean isFirstChildWildcard() {
        if ( this.children.isEmpty() ) return false;
        return this.children.get(0).isWildcard();
    }

    /**
     * Removes the first element from the defined parent and the children list.
     * @return the first element of the children
     * @throws NoSuchElementException if there are no children
     */
    public MatchablePomTaggedExpression removeFirst() throws NoSuchElementException {
        try {
            parent.getComponents().remove(0);
        } catch (IndexOutOfBoundsException ioobe) {
            throw new NoSuchElementException(ioobe.getMessage());
        }
        return this.children.removeFirst();
    }

    /**
     * @return true if this list of children is empty
     */
    public boolean isEmpty() {
        return this.children.isEmpty();
    }

    /**
     * @return the number of children
     */
    public int size() {
        return this.children.size();
    }

    /**
     * Matches children in a non-wildcard environment.
     * @param refComponents a copy of the children that must be matched.
     *                      This list will be manipulated, so do not provide
     *                      the original list of children to match.
     * @param config the matching configuration
     * @return true if it matches, false otherwise
     */
    public boolean matchNonWildCardChildren(
            LinkedList<PrintablePomTaggedExpression> refComponents,
            MatcherConfig config
    ) {
        int idx = 0;
        while (idx < size() && !refComponents.isEmpty()) {
            PrintablePomTaggedExpression firstRef = refComponents.removeFirst();
            MatchablePomTaggedExpression matcherElement = this.children.get(idx);

            if (!matcherElement.match(firstRef, refComponents, config)) return false;

            idx++;
        }

        return (config.allowFollowingTokens() && !refComponents.isEmpty()) || idx == size();
    }

    /**
     * Considers the children of this class as members of a sequence and matches them
     * against the the given sequence {@param expression}. This allows an in place matching,
     * meaning that it allows leading and following tokens that do not match the children.
     * It returns true if any subsequence of {@param expression} matches the this object.
     * @param expression the sequence to match
     * @param config matching config
     * @return true if any subsequence of {@param expression} matches, otherwise false. It only
     * captures the first identified match!
     */
    public boolean sequenceInPlaceMatch(PrintablePomTaggedExpression expression, MatcherConfig config) {
        List<PrintablePomTaggedExpression> children = expression.getPrintableComponents();
        LinkedList<PrintablePomTaggedExpression> backup = new LinkedList<>();
        MatchablePomTaggedExpression matchBackUp = null;

        // until we hit non-wildcard element
        while ( isFirstChildWildcard() ) {
            matchBackUp = removeFirst();
        }

        // start matching from here
        boolean findMatch = findNextMatch(expression, children, backup, config);
        if ( !findMatch ) return false;

        // rollback wildcards, but only take one hit
        rollbackSkippedWildcards(expression, backup, matchBackUp);

        return true;
    }

    private boolean findNextMatch(
            PrintablePomTaggedExpression expression,
            List<PrintablePomTaggedExpression> children,
            LinkedList<PrintablePomTaggedExpression> backup,
            MatcherConfig config
    ) {
        boolean currentMatch = parent.match(expression, new LinkedList<>(), config);
        while ( !currentMatch ) {
            if ( children.size() <= 1 ) return false;
            captures.clear();

            PrintablePomTaggedExpression firstElement = children.remove(0);
            expression.getComponents().remove(0);
            backup.add(firstElement);

            currentMatch = parent.match(expression, new LinkedList<>(), config);
        }

        return true;
    }

    private void rollbackSkippedWildcards(
            PrintablePomTaggedExpression expression,
            LinkedList<PrintablePomTaggedExpression> backup,
            MatchablePomTaggedExpression matchBackUp
    ) {
        if (matchBackUp != null) {
            PrintablePomTaggedExpression backupElement = backup.removeLast();
            captures.setCapturedGroup( matchBackUp.getWildcardID(), backupElement );
            this.children.addFirst(matchBackUp);
            parent.addComponent(0, matchBackUp);
            expression.addComponent(0, backupElement);
        }

        while ( !backup.isEmpty() ) {
            expression.addComponent(0, backup.removeLast());
        }
    }
}
